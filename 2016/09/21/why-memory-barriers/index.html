<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><meta name="keywords" content="cache,coherency,memory barrier,concurrency"><title>Why Memory Barriers | Words of MaciNian</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Why Memory Barriers</h1><a id="logo" href="/.">Words of MaciNian</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Why Memory Barriers</h1><div class="post-meta">Sep 21, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/09/21/why-memory-barriers/" href="/2016/09/21/why-memory-barriers/#comments" class="ds-thread-count"></a><div class="post-content"><blockquote>
<p>源于本周在组内做的一次小分享。起名为why memory barriers，其实并没有太多介绍memory barrier本身，而是从Cache、Multi-Core Processor等基础概念开始，介绍CPU在不断追求性能的过程中，衍生出来的一系列问题及其解决方案，即memory barrier产生的背景。  </p>
</blockquote>
<h2 id="1-Cache"><a href="#1-Cache" class="headerlink" title="1. Cache"></a>1. Cache</h2><h3 id="缓存是一个相对的概念"><a href="#缓存是一个相对的概念" class="headerlink" title="缓存是一个相对的概念"></a>缓存是一个相对的概念</h3><p>通常缓存特指介于CPU与内存之间且速度快于内存的<code>Cache System</code>。广义的缓存是在一个层次存储结构中的一个相对的概念，相对于它的下层，它的容量更小但是存取速度更快。以一种更宽泛的角度来理解缓存，更能触及缓存的本质。<br><img src="/images/20160921_cache.png" alt=""></p>
<p>例如通常把L1、L2、L3等多级缓存看为一个整体，作为相对于主存的缓存；但也可以把L1独立出来看，相对于L2来说L1就是缓存。另外主存也可以看作是本地磁盘的缓存；本地磁盘也可以看作是远端Web服务器的缓存。关键是理解这种设计思想。  </p>
<h3 id="缓存基于一个局部性假设"><a href="#缓存基于一个局部性假设" class="headerlink" title="缓存基于一个局部性假设"></a>缓存基于一个局部性假设</h3><p>缓存思想之所以成立的基础经常会被我们所忽略。其一，这是由于存储硬件的限制决定的，存储设备需要在“容量-速度-成本”之间权衡，在成本一定的条件下，容量与速度必定不可兼得，这是缓存成立的基础，否则意味着就要一个最大的最快的内存就可以了；其二，缓存基于局部性的假设，认为程序运行总是倾向于表现出局部性，包括时间局部性(<code>temporal locality</code>)和空间局部性(<code>spatial locality</code>)。时间局部性表示当一个内存地址被引用，那么在不久之后，这个内存地址还会被多次引用，因此当首次访问缓存不命中时，将其加载至缓存中才有意义；空间局部性认为当一个内存地址被引用，则其附近的地址后续也很可能会被引用，因此会从主存加载整个缓存行。  </p>
<h3 id="写比读复杂"><a href="#写比读复杂" class="headerlink" title="写比读复杂"></a>写比读复杂</h3><p>读缓存的工作流程很直观。当CPU读一个内存地址的时候，如果缓存命中则直接返回，否则就先从内存中加载至缓存，然后再将其返回。相对来讲写缓存就更复杂些。<br>首先在写命中(<code>write hit</code>)的情况下，写命中指的是要写的这个内存地址已经在缓存中，此时有两种写策略供选择，分别是直写(<code>write-through</code>)和写回(<code>write-back</code>)。直写策略比较简单，直接将相应的更新的缓存行写到内存(下一层存储)中；而写回策略则只更新缓存行并将其标记为<code>dirty</code>，尽量延迟往下一层存储写的时间，这种策略的优势在于减少了总线通信的开销，当一个被标记为<code>dirty</code>的缓存行需要被替换出缓存的时候，则必须先将其刷至下一层存储。<br>其次在写缺失(<code>write miss</code>)的情况下，写缺失指的是要写的这个内存地址当前不在缓存中，这个时候也有两种不同的处理方式，分别是写时分配(<code>write-allocate</code>)和写时不分配(<code>no-write-allocate</code>)，写时分配指的是先从内存加载对应的缓存行，然后再更新这个缓存行；写时不分配则是直接写下一层存储。<br>上述写策略(也包括缓存系统中常用的替换算法等的选择)，对于多级缓存结构来说，并没有要求各级保持一致，比如L1可以是<code>write-through</code>，同时L2可以是<code>write-back</code>策略。  </p>
<h2 id="2-Multi-Core"><a href="#2-Multi-Core" class="headerlink" title="2. Multi-Core"></a>2. Multi-Core</h2><p>对于单核CPU来讲，上述缓存结构可以很好的工作；但是到了多核环境下就会存在问题。如图是Intel  Core i7的高速缓存层次结构示意图，可以看到每个Core有各自独立的L1和L2缓存，简单来说问题就是当Core1写了它私有的Cache之后，由于其他Core无从知晓，导致它们之间的数据不一致。需要思考的这是一个<code>multi-core problem</code>还是<code>multi-cache problem</code>？  </p>
<p>其实多核本身并没有问题，因为我们可以通过把L1、L2也都变成所有Core共享的缓存来解决上述问题，只是这种解决方案会拖慢CPU的速度，因为每个Core需要更多的时间用于竞争和等待L1为其服务；所以它本质上是一个<code>multi-cache problem</code>，而不是<code>multi-core problem</code>。因此问题的本质应该是一个分布式系统的问题，在于如何保持缓存一致性。<br><img src="/images/20160921_intel_i7.png" alt=""></p>
<h2 id="3-Cache-Coherency"><a href="#3-Cache-Coherency" class="headerlink" title="3. Cache Coherency"></a>3. Cache Coherency</h2><p>因此就有了缓存一致性协议(Cache Coherency Protocol)这个概念，其致力于保持缓存数据的一致性。</p>
<h3 id="Basic-Idea-Behind-Snooping"><a href="#Basic-Idea-Behind-Snooping" class="headerlink" title="Basic Idea Behind Snooping"></a>Basic Idea Behind Snooping</h3><p>大多数缓存一致性协议都基于嗅探(<code>snooping</code>)的理念。嗅探的思想是基于所有的内存读写事务都需要经过共享的总线，因此各个独立的Core/Cache可以通过对总线的持续嗅探，来及时跟踪其他Core的行为来同步缓存数据。例如当Core1写了某个内存地址之后，其他的Core就可以及时将它们相应的缓存行置为无效。  </p>
<h3 id="Why-MESI-snooping-is-not-enough"><a href="#Why-MESI-snooping-is-not-enough" class="headerlink" title="Why MESI (snooping is not enough)"></a>Why MESI (snooping is not enough)</h3><p>但是如果采用了<code>write-back</code>策略，则会使得嗅探策略失效。因为写回策略会尽量延迟往下一层存储写的时间，当一个Core执行写操作，它只是更新了对应缓存行数据，也就使得当其他Core从总线得知这个消息的时间存在较大的延时而导致数据不一致，其他Core有可能使用一个旧的值，如果其他Core也准备写这个内存地址，还会导致冲突。  </p>
<p>MESI协议可以提供缓存一致性保证，首字母分别表示缓存行的四种状态：Modified、Exclusive、Shared和Invalid。其基本思想是每个Core只允许更新被其独占的缓存行(处于Exclusive或Modified状态)，举例简单说明一下它的工作流程：假设现在Core0~Core3的L1缓存均分别有a=1的缓存，则这些缓存行的状态均为<code>Shared</code>；此时Core0想将a变量更新为2，但是不同的是它必须先征得其他Core的同意，Core0首先向其他Core发出<code>Invalidate</code>消息，其他Core收到消息后会将a=1缓存行置为<code>Invalid</code>状态并回复ack，Core0收到所有ack之后会将其a=1的缓存行置为<code>Exclusive</code>状态，表示该缓存行先已被Core0独占，更新a=2之后，该缓存行变更为<code>Modified</code>状态表示值已更新。如图是摘自wikipedia的MESI状态流转图。<br><img src="/images/20160921_mesi.png" width="50%" height="50%" align="center/"></p>
<h2 id="4-Why-Memory-Barriers"><a href="#4-Why-Memory-Barriers" class="headerlink" title="4. Why Memory Barriers"></a>4. Why Memory Barriers</h2><p>实际上MESI协议提供了强一致性的保障(<code>Sequential Consistency</code>), 那为什么在写并发程序的时候还是会面临乱序、可见性等问题呢？  </p>
<h3 id="Store-Barrier-amp-Store-Buffer"><a href="#Store-Barrier-amp-Store-Buffer" class="headerlink" title="Store Barrier &amp; Store Buffer"></a>Store Barrier &amp; Store Buffer</h3><p>MESI协议用于保持缓存一致性带来的性能开销不容小觑，因此CPU并没有完全遵从MESI协议，会引入一些优化的措施，例如<code>store buffer</code>、<code>invalidate queue</code>等。下面简单介绍<code>store buffer</code>的优化策略，<code>invalidate queue</code>的优化及其他更细节的内容建议仔细阅读参考文章4<code>perfbook附录C</code>一文。<br>假设当前CPU0和CPU1均各自持有a=1的缓存行，此时CPU0想更新a=2，那么在MESI协议的规范下，CPU0必须先跟CPU1”协商”，先发出<code>Invalidate</code>消息，CPU1收到消息后会将a=1缓存行置为<code>Invalid</code>状态并回复ack，CPU0再收到ack消息之后才能写缓存，如图可以明显看到CPU0有一个明显的等待时间。<br><img src="/images/20160921_write_stall.png" alt=""></p>
<p>引入<code>store buffer</code>的优化策略就是要尽量缩短其等待时间，基于类似异步思想：CPU0写把a=2写的别的地方记录一下，然后就不等待继续往下执行，等ack回来的时候，再将记录的a=2真正刷到缓存中。如图是引入<code>store buffer</code>之后的CPU缓存结构示意图，优化之后的流程变为：CPU0还是先发出<code>Invalidate</code>消息，然后把a=2写到其<code>store buffer</code>中，然后就不等待继续往后执行；CPU1收到消息之后，将a=1缓存行置为<code>Invalid</code>状态并回复ack；CPU0收到ack之后才真正将a=2从其<code>store buffer</code>写到缓存中。<br><img src="/images/20160921_store_buffer.png" alt=""></p>
<p>可以注意到实际上<code>store buffer</code>的引入破坏了MESI协议的强一致性保障，因为虽然对于CPU0来说，可以通过<code>store forwarding</code>手段能够读取到<code>store buffer</code>中最新的值，但是对于其他CPU来说却是不可见的。  </p>
<p>这个时候就需要<code>store barrier</code>出场了，<code>store barrier</code>的作用是：所有在<code>store barrier</code>之前store指令从当前CPU的<code>store buffer</code>中写入到cache系统中。这使得当前程序状态（当前CPU在<code>store barrier</code>之前的写操作）对其他CPU可见。<br>由此可见barrier是有损于CPU的性能的，就本例来讲如果CPU0写a=2之后存在一个<code>store barrier</code>指令，则相当于反向阻止了异步化的优化，强迫CPU0等待。那么先弄了个异步化的优化，又引入barrier抵消该优化是否有意义呢？这是有意义的，因为程序员可以利用barrier这个工具在必要时保障并发程序的正确性，而在没有必要的时候，则给CPU松绑提升程序执行性能。  </p>
<h3 id="Load-Barrier-amp-Load-Buffer"><a href="#Load-Barrier-amp-Load-Buffer" class="headerlink" title="Load Barrier &amp; Load Buffer"></a>Load Barrier &amp; Load Buffer</h3><p>另外CPU的推测执行(<code>Speculative Execution</code>)也会造成MESI协议的失效。推测执行基于这样一种想法：在一件事情需不需要被执行尚未明确的时候，就可以提前执行它，因为如果等到已经明确需要执行的时候再去执行，必定导致等待，因此CPU基于性能考虑，有可能会进行推测执行,例如分支预测(<code>branch prediction</code>)、预加载(<code>prefetching memory</code>)等。<br>CPU为了发挥其性能会做一些”预测性的load”，比如预先执行一些load指令把结果暂存于当前CPU的<code>load buffer</code>中，那么就可能导致其他CPU的一些store操作，由于相应的变量被预先load，表现出对当前CPU不可见的现象。<code>load barrier</code>的作用是：所有在<code>load barrier</code>之后的load指令会等待<code>load buffer</code>被排空，相当于保证了这些load指令的顺序是“真正”发生在barrier之后的，而不是预先load的结果。这使得其他CPU的写操作（程序状态的改变）对当前CPU可见。  </p>
<h2 id="5-Performance"><a href="#5-Performance" class="headerlink" title="5. Performance"></a>5. Performance</h2><p>一切为了性能。Cache System、Multi-Core、MESI及其优化、CPU的乱序执行，几乎所有的新技术的发明都是为了性能的提升，与此同时也会导致原有的一些保障和规范被打破，MESI协议、Memory Barrier等措施用于弥补被打破的保障，而后又开始了新一轮的性能优化。  </p>
<h2 id="6-References"><a href="#6-References" class="headerlink" title="6. References"></a>6. References</h2><p>（1）English Grammar in Use. (感觉阅读英语长句障碍，越早补上这个短板，浪费的时间就越少)<br>（2）Computer Systems A Programmer’s Perspective Chapter 6. 关于缓存的理解<br>（3）<a href="https://fgiesen.wordpress.com/2014/07/07/cache-coherency/" target="_blank" rel="external">Cache coherency primer</a> 深入浅出讲解缓存及缓存一致性<br>（4）<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html" target="_blank" rel="external">perfbook附录C</a> why memory barriers  </p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://macinian.com/2016/09/21/why-memory-barriers/" data-id="cite1ui570000u8byhdh5w3jv" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Concurrency/">Concurrency</a><a href="/tags/Memory-Barrier/">Memory Barrier</a></div><div class="post-nav"><a href="/2016/08/26/memory-barrier/" class="next">Memory Barrier</a></div><div data-thread-key="2016/09/21/why-memory-barriers/" data-title="Why Memory Barriers" data-url="http://macinian.com/2016/09/21/why-memory-barriers/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/09/21/why-memory-barriers/" data-title="Why Memory Barriers" data-url="http://macinian.com/2016/09/21/why-memory-barriers/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://macinian.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Concurrency/" style="font-size: 15px;">Concurrency</a> <a href="/tags/Memory-Barrier/" style="font-size: 15px;">Memory Barrier</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/why-memory-barriers/">Why Memory Barriers</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/26/memory-barrier/">Memory Barrier</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Words of MaciNian.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'macinian'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?54d4e6f51ca098a79d48a2a5312443f8";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>