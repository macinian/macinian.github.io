<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Synchronizer | Words of MaciNian</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Synchronizer</h1><a id="logo" href="/.">Words of MaciNian</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Synchronizer</h1><div class="post-meta">Nov 13, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/11/13/synchronizer/" href="/2016/11/13/synchronizer/#comments" class="ds-thread-count"></a><div class="post-content"><blockquote>
<p>对《Java Concurrency in Practice》 第14章的阅读与理解：主要关于Synchronizer如何协调和同步多线程程序的正确执行，条件队列的演进、锁与条件对象的关系以及AQS的设计与实现。  </p>
</blockquote>
<h2 id="1-状态依赖性的管理"><a href="#1-状态依赖性的管理" class="headerlink" title="1. 状态依赖性的管理"></a>1. 状态依赖性的管理</h2><p>在并发程序中，状态依赖性问题很常见，例如有界队列的put与get操作分别依赖队列的满或空的状态，获取一次异步计算结果的操作依赖计算是否完成的状态。对状态依赖性的管理策略都是在回答同一个问题：如果条件/状态判定不满足怎么办？是抛出异常，或者轮询等待，还是有其他更高效的方式？  </p>
<p>下面以有界队列的put操作为例来介绍常见的处理方式。  </p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public synchronized void put(V v) throws BufferFullException &#123;</div><div class="line"></div><div class="line">    if (isFull()) &#123;</div><div class="line">        throw new BufferFullException();</div><div class="line">    &#125;</div><div class="line">    doPut(v);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种处理方式被称为<code>将前提条件的失败传递给调用者</code>，这是一种简单直观的实现，但它的缺陷在于<code>调用者不友好</code>。因为这实际上是把状态依赖性问题抛给了调用者，从而调用者必须自行处理前提条件失败的情况。调用者不仅需要捕获异常，还必须自行实现循环重试的策略，作为开发人员应该都不太会喜欢调用这种方式的API或工具类。  </p>
<h3 id="轮询与休眠"><a href="#轮询与休眠" class="headerlink" title="轮询与休眠"></a>轮询与休眠</h3><p>第二种方式实际上是紧接着上述调用者不友好的问题而提出的解决方案，通过简单的<code>轮询与休眠</code>的重试机制，将<code>前提条件失败的处理逻辑</code>封装好，从而使得调用者不用自行处理。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void put(V v) throws InterruptException &#123;</div><div class="line"></div><div class="line">    while (true) &#123;</div><div class="line">        synchronized (this) &#123;       // 获取锁</div><div class="line">            if (!isFull()) &#123;        // 判断条件</div><div class="line">                doPut(v);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Thread.sleep(INTERVAL);     // 释放锁并睡眠</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意在循环重试中对锁的获取与释放：首先，测试前提条件是否为真之前需要获取锁以保障测试结果的有效性；其次，测试失败线程进入睡眠之前需要释放锁，否则可能由于条件永远无法为真而进入死循环。同时对线程睡眠间隔的选择需要在响应性和CPU使用率之间进行权衡。  </p>
<p>这种处理方式<code>通过轮询与休眠实现了简单的阻塞</code>，从调用者视角来看，达到了如果某个操作满足条件则立即执行，否则就阻塞的效果，调用者不用自行处理条件失败和重试。但是线程的循环睡眠和重试这种方式，给程序带来不小的上下文切换开销，同时CPU使用率和响应性之间的权衡也并非最佳，因为当条件/状态没有改变时的每一次重试其实都是浪费的，并且为了权衡资源开销，响应性做出了部分牺牲。<br>那么是否存在一种机制，使得当条件不满足时挂起线程，当后续条件满足时被挂起的线程能够立即被唤醒以重新测试条件。  </p>
<h3 id="内置条件队列"><a href="#内置条件队列" class="headerlink" title="内置条件队列"></a>内置条件队列</h3><p><code>条件队列</code>保存那些因为条件失败而需要阻塞等待的线程对象。通过<code>synchronized</code>关键词每个Java对象都可以作为一个内置锁，同样每个Java对象都可以作为一个条件队列，在Object基类中提供了wait、notify、notifyAll等内部条件队列使用的API。如下代码通过内置条件队列来实现有界队列的put/get操作：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public synchronized void put(V v) throws InterruptException &#123;</div><div class="line"></div><div class="line">    while (isFull()) &#123;      // 重试判断条件</div><div class="line">        wait();             // 不满足: 释放锁-挂起-被唤醒时再获取锁</div><div class="line">    &#125;</div><div class="line">    doPut(v);</div><div class="line">    notifyAll();            // 条件改变，唤醒其他线程</div><div class="line">&#125;</div><div class="line"></div><div class="line">public synchronized V get() throws InterruptException &#123;</div><div class="line"></div><div class="line">    while (isEmpty()) &#123;</div><div class="line">        wait();</div><div class="line">    &#125;</div><div class="line">    V v = doGet();</div><div class="line">    notifyAll();</div><div class="line">    return v;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与<code>轮询休眠</code>方式相比，<code>条件队列</code>减少了在条件/状态没有改变时进行无效重试，从而降低上下文切换、CPU时间片占用等系统资源的开销，同时当条件变化时能够得到及时的通知，使得其响应性也更好，所以条件队列在表达和管理状态依赖性时更加简单和高效。  </p>
<h2 id="2-正确使用条件队列"><a href="#2-正确使用条件队列" class="headerlink" title="2. 正确使用条件队列"></a>2. 正确使用条件队列</h2><p>条件队列容易被不正确的使用，正确使用基于对细节的完整理解。  </p>
<h4 id="锁与条件队列"><a href="#锁与条件队列" class="headerlink" title="锁与条件队列"></a>锁与条件队列</h4><p>对象的内置锁与条件队列相互关联的，要调用一个对象内置条件队列的方法，前提是首先获取该对象的锁。在介绍原因之前，先引入一个概念<code>条件谓词</code>：由类中各个状态变量构成的表达式。例如：<code>队列满</code>是一个条件谓词，其表达式就是<code>count == len(queue)</code>；同样，<code>队列为空</code>也是一个条件谓词，表达式是<code>count == 0</code>。  </p>
<p><img src="/images/20161113_condition_wait.png" alt=""></p>
<p>只有当能够对条件谓词进行检查时，发现不满足，才能在这个条件谓词上进行等待；条件谓词又是由类中状态变量构成的，而这些状态变量由对象锁进行保护，因此需要先获取该对象的锁。实际上，如果在没有持有对象锁的情况下调用该对象条件队列的wait方法，Java会抛出<code>IllegalMonitorStateException</code>异常。同理，只有当能够修改这些状态使得一个条件谓词判断结果改变，才能将等待在该条件谓词上的线程进行唤醒。    </p>
<h4 id="wait与条件谓词判断"><a href="#wait与条件谓词判断" class="headerlink" title="wait与条件谓词判断"></a>wait与条件谓词判断</h4><p>条件队列的正确使用方式是在一个循环中调用wait，在wait调用之前测试条件谓词，并且从wait返回时再次进行测试。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (isFull()) &#123;      // 测试条件谓词</div><div class="line">    wait();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在wait调用之前测试条件谓词是为了防止因<code>信号丢失</code>而引起活跃性故障，例如线程A通知了一个条件队列，随后线程B在这个条件队列中等待，如果在等待之前没有测试条件谓词，将会导致线程B等待一个已经为真的条件谓词，从而无法立即被唤醒，需要等到下一次通知到来。<br>在wait返回时必须重新测试条件谓词。首先，线程有可能被<code>过早唤醒</code>，即当线程由于notifyAll而醒来时，并不意味着其等待的条件谓词一定变为真，根本原因在于同一个条件队列中可能存在多个条件谓词。其次，即使确实是由于该线程所等待条件谓词变为真而导致的唤醒，由于在该线程被唤醒到重新获取锁的时间段内存在着<code>数据竞争</code>，也不能保障此时改条件谓词依然为真。因此在wait返回时重新测试条件谓词是必要的。  </p>
<h4 id="notify与notifyAll"><a href="#notify与notifyAll" class="headerlink" title="notify与notifyAll"></a>notify与notifyAll</h4><p>调用notify方法，JVM会从该条件队列上等待的多个线程中选择一个进行唤醒；调用notifyAll方法则会唤醒该条件队列上等待的所有线程。如果在上述有界队列的实现中使用notify来替代notifyAll，则会导致程序不能正常工作。根本原因在于：同一个条件队列上等待的线程，基于的条件谓词可能是不一样的，如下图所示，<code>not_empty</code>和<code>not_full</code>分别是该条件队列上的两个不同的条件谓词，分别有不同的线程在这两个条件谓词上等待，使用notify方法进行唤醒，有可能选择的是另一个条件谓词上的线程，从而导致<code>信号丢失</code>的风险。<br><img src="/images/20161113_condition_multi_wait.png" alt=""></p>
<h4 id="显式的Condition对象"><a href="#显式的Condition对象" class="headerlink" title="显式的Condition对象"></a>显式的Condition对象</h4><p>从notify和notifyAll问题的描述中可以看到使用内置条件队列的缺陷，即每个内置锁和内置条件队列是一对一关联的，如果在该条件队列上存在多个条件谓词，则唤醒等待线程只能选用notifyAll，从而导致对部分线程产生多次无效的唤醒浪费。JUC中提供的显式锁<code>Lock</code>和<code>Condition</code>对象相对来讲则更加灵活，首先可以通过<code>lock.newCondition</code>方法在lock对象上绑定多个条件队列，例如<code>not_empty</code>和<code>not_full</code>可以是分别的两个条件队列，在唤醒的时候可以更高效，减少不必要的唤醒带来的资源开销；其次，显式Conditon对象提供了更丰富的功能，例如等待的可中断、不可中断、可超时以及公平和非公平等特性。  </p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>在并发程序中，状态依赖性问题很常见，条件队列是表达和管理并发环境下状态依赖性的同步器。本文主要介绍了条件队列的演进以及正确使用条件队列需要注意的地方。<br>另外，关于对锁和条件队列的理解：锁是并发程序中最常见的同步器，用于控制多个线程的执行能否重叠，可以独立于条件队列使用；而条件队列必须结合锁来使用，在获取锁之后，判断条件谓词是否满足，不满足则释放锁并挂起线程，等待条件谓词变为满足时被唤醒。<br>如图，a0、a1表示在线程A上发生的事件，b0、b1表示在线程B上发生的事件；A0和B0分别表示相应的两个事件之间时间区间，A0和B0有可能发生重叠，通过锁的使用可以使得A0和B0变为串行执行，从而避免可能出现的数据竞争，保障并发程序的正确性。而条件队列的使用需要在获取到锁的前提下，通过对条件谓词进行检查，从而处理状态依赖性问题。  </p>
<p><img src="/images/20161113_interval_overlap.png" alt=""></p>
<p><img src="/images/20161113_interval_disjoint_condition.png" alt=""></p>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p>（1）Java Concurrency in Practice, Chapter 14<br>（2）The Art of Multiprocessor Programming, 关于事件、时间区间与并发的理解</p>
<blockquote>
<p>待续：AQS和CLH队列、AQS之核心数据结构  </p>
</blockquote>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://macinian.com/2016/11/13/synchronizer/" data-id="civgs3bw10003kxs6nci0qafa" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Synchronizer/">Synchronizer</a><a href="/tags/Lock/">Lock</a><a href="/tags/Condition/">Condition</a><a href="/tags/AQS/">AQS</a><a href="/tags/CLH/">CLH</a></div><div class="post-nav"><a href="/2016/11/02/java-executor-framework/" class="next">Java Executor Framework</a></div><div data-thread-key="2016/11/13/synchronizer/" data-title="Synchronizer" data-url="http://macinian.com/2016/11/13/synchronizer/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/11/13/synchronizer/" data-title="Synchronizer" data-url="http://macinian.com/2016/11/13/synchronizer/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://macinian.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Memory-Barrier/" style="font-size: 15px;">Memory Barrier</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Future/" style="font-size: 15px;">Future</a> <a href="/tags/ThreadPool/" style="font-size: 15px;">ThreadPool</a> <a href="/tags/Concurrency/" style="font-size: 15px;">Concurrency</a> <a href="/tags/Executor/" style="font-size: 15px;">Executor</a> <a href="/tags/Synchronizer/" style="font-size: 15px;">Synchronizer</a> <a href="/tags/Lock/" style="font-size: 15px;">Lock</a> <a href="/tags/Condition/" style="font-size: 15px;">Condition</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a> <a href="/tags/CLH/" style="font-size: 15px;">CLH</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/13/synchronizer/">Synchronizer</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/02/java-executor-framework/">Java Executor Framework</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/why-memory-barriers/">Why Memory Barriers</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/26/memory-barrier/">Memory Barrier</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Words of MaciNian.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'macinian'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?54d4e6f51ca098a79d48a2a5312443f8";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>